ch
【转】基于数据库在 Rational Functional Tester 中实现多语言用户界面（UI）测试
Extracted from http://www.ibm.com/developerworks/cn/rational/r-cn-rftdatabaseduitest/index.html?ca=drs-? 随着软件全球化的发展，测试人员也对全球化软件多语言图形用户界面（UI）的自动化测试提出了更高的要求，IBM Rational Functional Tester（RFT）就是针对全球化多语言应用程序图形用户界面（UI）的有效自动化测试工具之一。RFT 基于 Java 语言的自动化测试开发工具，通过其自身的静态识别对象技术或者动态对象识别技术来执行，或验证不同的 UI 对象，如用户通过静态 TestObjectMap 来获取对象，或者 TestObject 的 find 等方法来动态获取对象。 静态获取对象的方法简单实用，用例执行效率高，但执行多语言测试时，需要维护多个语言版本的 TestObjectMap，当测试对象发生改变时，需要更新多个 TestObjectMap，可维护性比较差；动态获取对象的方法实现复杂一些，对多语言测试只需要维护多个属性（.properties）文件，因此可 维护性较好，但用例执行时效率较低，对于需要大量快速执行的用例是个问题。 本文先介绍如何使用 RFT 的静态获取方法和动态获取方法实现多语言 UI 测试，随后针对静态获取方法管理 TestObjectMap 的不足，给出一种基于数据库实现的维护 TestObjectMap 和属性文件的多语言 UI 的测试方法。 静态获取方法是通过 RFT 提供的测试对象获取功能得到多语言的 UI 对象，然后添加到相应的 RFT 文件中，再通过初始化（Getter）函数来完成对象的静态识别。图 1 是一个待测试对象的对话框，其中包含了对话框（WFrame），按钮（WButton），文本（WStaticText），列表（WListBox）等控 件。 在 Private Test Object Map 中，从菜单中选择 Test Object Insert Object(s)，将 Object Finder 控件拖到待测试对象对话框上，以使整个对话框四周包围着一个红色方框，然后释放鼠标按钮，在 Insert a GUI Object into the Object Map 对话框中，选择 Include all available objects on this window 并单击 Finish。这样当前对话框下所有可用的对象都被加入到了 TestObjectMap 中。如图 2 所示，每个对象可以由多个属性综合来识别，每个属性有识别值（Value）和相应权重（Weight），同时，每个对象的所有父对象也会影响到识别的准确 性。对属性值设置正则表达式的识别方式，可以一定程度上减少因为对象属性值更新而带来的对象重新获取的工作。这里需要指出的是 Test Object Map 相对应的 RFT 文件就是 .rftxmap 文件。 在 TestObjectMap 中获取对象后，选择需要关联到 java 代码文件中的对象，在菜单中选择 Test Object Add to Script，将获取到的对象关联到 java 代码文件中，就是图 3 中右边视图中描述的对象，这些对象就是从 TestObjectMap 中关联进来的，相应描述这些关联对象的 RFT 文件就是 . rftdef 文件，可以看出这个视图中的对象是 TestObjectMap 的一个子集。 经过关联对象后，需要在相应 java 代码文件中，加入类似如图 3 左边的代码来初始化（Getter）识别对象。之后就可以在程序中通过 getBtn_ok() 方法来获得识别到的对象，进行相应的对象操作或者验证。针对多语言的 UI 对象测试，就需要重复第一步获取每种语言下测试对象的属性，或者使用 TestObjectMap 中，Test Object Update Recognition Properties 功能更新每一个对象的识别属性，然后根据各种语言分别保存所有对象层的资源文件，如图 4 所示，当需要测试相应语言时，就将对应的语言文件夹重命名，如需要测试日文时，将文件夹 appobjects_JP 重命名为 appobjects。 经过以上步骤就实现了用静态获取方法进行多语言 UI 的测试，可以看出如果当测试多种语言，以及同一个产品的不同版本时，这种方法就需要管理多个测试对象资源文件夹，并在测试对应语言，版本时作相应替换，给 测试维护工作带来一定的复杂度，文件的丢失或更改会极大的影响测试脚本的执行，容易产生混淆。 动态获取对象的方法不需要进行测试对象关联，针对多语言的测试，也不需要管理多个测试对象资源文件夹，通常是使用 TestObject.find 方法，结合多语言资源文件（如 messages_en_US.properties，messages_zh_CN.properties），在程序运行时动态加载对象属性，动态识别 对象。为了能够读取绑定资源文件中的键值，需要定义一个 Message 类来实现 import java.util.MissingResourceException; import java.util.ResourceBundle; public class Messages extends MessagesHelper { public static String getString(String key, ResourceBundle RESOURCE_BUNDLE) { try { return RESOURCE_BUNDLE.getString(key); } catch (MissingResourceException e) { return '!' + key + '!'; } } } 在多语言资源文件中定义待识别对象的关键属性值，需要注意的是，在 RFT 中的文本编辑使用 cp1252 编码，因此不支持直接录入中文等东方文字，需要将这些文字转换成 UTF-8 的编码值进行录入，如“确定”的 UTF-8 值为“\u786E\u5B9A”。 绑定多语言资源文件，通过以下代码可以将包含对象属性多语言资源文件绑定到 RESOURCE_BUNDLE 对象中，getBundle() 的第二个参数可以根据测试需要设置不同语言的 Local 来切换到其他语言的测试，getBundle() 可以根据 Local 自动绑定相对应语言的资源文件。 import java.util.Locale; public static ResourceBundle RESOURCE_BUNDLE = ResourceBundle.getBundle("tasks.BackTranScores.messages",Locale.SIMPLIFIED_CHINESE); 利用 TestObjectMap 来确定需要识别对象的关键属性。动态识别方法在运行时并不需要 TestObjectMap，但是在写 TestObject 的 find 等方法时，需要确定对象的关键属性，这样 RFT 运行时才能够在众多的 UI 对象中，准确的找到特定识别对象，创建 TestObjectMap 可以参照静态识别方法的步骤一，但要确定每一个对象的关键属性则根据项目的不同，需要多调试才能够确定，一般来说，如图 2 通过一个对象的 class，accessibleContext.accessibleName，captionText 等属性就可以基本上确定一个对象，但当两个对象的这些属性都相同时，就需要根据他们的父对象来区分出具体的一个对象。确定识别出唯一的父对象作为其他子对象的识别很重要，如针对图 1 的 UI 测试，则所有按钮（WButton），文本（WStaticText），列表（WListBox）等控件的父对象都是一个对话框（WFrame），其关键 属性是 captionText，其值为“逆转换得分”，因此可以通过下面代码来确定这个唯一的父对象： public WFrame getDlg_BackTranScores () { TestObject[] to = getRootTestObject().find(atDescendant(".captionText", utilities.Messages.getString("Dlg.captionText", BackTranScores.RESOURCE_BUNDLE))); if (to.length 1) throw new AmbiguousRecognitionException( "Search criteria failed to uniquely identify dialog."); if (to.length 1) throw new ObjectNotFoundException("Failed to find the dialog."); return new WFrame(to[0]); } 在确定父对象后，就可以通过在父对象中搜索每一个子对象控件了，如下面代码通两个关键属性，在 getDlg_BackTranScores () 中找出唯一的“确定”按钮 : public WButton getBtn_OK() { TestObject to[] = getDlg_BackTranScores ().find(atDescendant( ".class", "javax.swing.JButton", "accessibleContext.accessibleName", utilities.Messages.getString("Dlg.BtnOK", BackTranScores.RESOURCE_BUNDLE))); if (to.length 1) throw new AmbiguousRecognitionException( "Search criteria failed to uniquely identify Button."); if (to.length 1) throw new ObjectNotFoundException("Failed to find the Button."); return new WButton(to[0]); } 经过以上步骤，就实现了用动态识别的方法进行多语言 UI 的测试，在上面的实例中，代码使用 atDescendant 来定位按钮。然而，您可以有许多方式来使用 find：atChild 搜索 TestObject 所有直接的子对象。atDescendant 寻找 TestObject 的所有子对象。atList 让您指定一个 atChild、atDescendant，和 atProperty 对象的列表，这样您可以减小搜索范围。 静态获取实现多语言 UI 测试的方法，较为简单，开发工作量小，因为已经有 TestObjectMap 存储好了对象属性，因此在用例执行时效率高，速度快，但当对象属性发生变化时，需要更新维护的 TestObjectMap 工作量较大，对于多语言的测试，则需要维护不同版本，不同语言的资源文件夹，较为复杂，容易产生管理混乱。 动态识别实现多语言 UI 测试的方法，实现上较为复杂一些，对于不同语言的对象属性信息需要进行 UTF-8 的转换，在程序运行时不需要 TestObjectMap，但在开发时需要使用，因此动态识别的开发量要稍大一些，另外，因为总是在程序运行是动态识别对象，因此当 UI 对象复杂时识别速度较慢，但对于多语言的维护则相对简单，只需要维护多个属性文件即可。 　静态获取方法动态获取方法实现复杂度简单较复杂可维护性较复杂简单对象识别速度较快较慢 因此静态识别和动态识别的方法各有优势，适用于不同的项目背景，对于 UI 比较稳定的产品测试，需要快速执行用例的时候可以用静态识别来实现，对于常在更新维护的产品测试，可以考虑用动态识别来实现，有时候也可以两者结合来实现 多语言 UI 的测试，总之可以根据各自项目情况来决定。 根据以上讨论，如果采用静态识别的方法来支持多语言测试，用户需要维护不同语言的 TestObjectMap，增加了维护成本。我们看到每个控件只有某些属性是和语言相关的例如 accessibleName，那我们能不能将语言相关的属性提取出来保存在 TestObjectMap 的外部，在需要测试不同语言的时候将这些属性重新写入 TestObjectMap 呢？答案是肯定的，这一节我们就来讲述如何采用数据库来完成这个任务。 要 将静态对象中和语言相关的属性标识出来。通过分析，我们知道静态对象是存储在 .rftxmap 文件中，格式为 XML。如果一个属性的值为正则表达式，它的存储格式如清单 5 所示，标签“.RegExp”表明该属性值为正则表达式。因此我们将所有语言相关的属性值都设置为正则表达式，这样就能将它们识别出来。如清单 5 中的文件，我们将会识别到 accessibleContext.accessibleName 属性，并将他的值“Categorical Variables:”一同存储到稍后建立的数据库中。 Key accessibleContext.accessibleName /Key Val L=".RegExp" Pattern Categorical Variables: /Pattern CaseSensitive true /CaseSensitive Original Categorical Variables: /Original /Val 将测试中动态生成的和语言相关的字符串提取出来保存在资源文件中，资源文件采用 Key 和 Value 的格式保存每条记录。这些记录会存储到稍后建立的数据库中。 创建数据库用来保存所用多语言相关的资源。数据库的创建再下一节中详细介绍。 程序实现，该程序的主要功能如下： 遍历并解析所有 TestObjectMap 文件即 .rftxmap 文件，获取所有正则表达式的属性并调用数据库的存储过程将数据写入数据库。如果已经有相应数据则对数据进行更新。遍历所有资源文件即 .properties 文件，将对应的 Key 和 Value 写入数据库。如果已经有相应数据则对数据进行更新。执行测试用例前，根据所选语言从数据库中获取相应数据，重新下载生成相应静态 TestObjectMap 文件（.rftxmap）和资源文件（.properties）。 数据库结构如图 6 所示： PropertyFile 表和 ExtStrings 表用来存储资源文件数据，每一个测试脚本的资源文件都会对应 PropertyFile 表中的若干记录，记录的个数为所支持的被测产品的版本数量，用 VersionID 字段加以区分。File 字段代表该资源文件所属脚本的路径。ExtStrings 表中的每条记录就是一个资源文件中的键值对，Key 字段表示键值的名称，相应的语言字段代表实际的值，如 English 为该键值的英文值，German 为德文值，这样要支持某种语言我们只需添加相应字段。 Pattern，Object，Map 这三个表用来实现 TestObjectMap 中多语言属性的存储。每一个 TestObjectMap 都对应 Map 表中的若干记录，记录的个数为所支持的被测产品的版本数量，用 VersionID 字段加以区分，FilePath 字段表示该 TestObjectMap 的存储路径。Object 表中的每条记录为 TestObjectMap 中和语言相关的对象控件，Object 字段为该对象名称，MapID 指明它所属于的 TestObjectMap。Pattern 表中的每条记录代表该对象的一个和语言相关的属性，Property 字段指明属性名称，不同的语言字段标识该语言的属性值，如 English，标识该属性所对应的英文属性值。 我们采用 Java 语言来实现程序用来链接 RFT 和数据库，对于静态 TestObjectMap 内的属性的更新我们采用以下类来实现如图 7 所示。 TestObjectDetails 类是对一个 TestObjectsMap 中某一个对象所有语言相关属性的抽象，这些需要更新的属性以哈希表的格式存储在属性 propPattern 内。TestObjects 类则包含某一个 TestObjectsMap 中所有语言相关属性的集合，我们看到这些属性以哈希表的格式存储在 testObjects 属性内。TestMaps 则是对项目中所有 TestObjectsMap 抽象，所有 TestObjects 以哈希表的格式存储在属性 testMaps 中。UpdateDatebase 类负责将这些属性更新到数据库中。LocalizeMaps 类负责从数据库中读取属性并产生新的 TestObjectsMap 供 RFT 使用。 我们希望每次更新数据库和生成新的 TestObjectsMap 时，不是将他们全部更新，而是根据需求更新必要的，我们可以看到在 UpdataDatabase 类中的方法 getParamXML()，该方法将生成一个 XML 文件指明哪些 TestObjectMap 需要更新，同时 LocalizeMaps 中的方法 updateMapsInFolder() 也会根据该 XML 文件的设置来产生相应的 TestObjectMap 文件。该文件如下所示。Process 为 true 说明该 TestObjectMap 文件需要更新，false 说明不需要更新。 ?xml version="1.0" ? Maps Map filePath="appobjects\TestOne\PIOC.rftxmap" process="false" / Map filePath="appobjects\TestOne\Save.rftxmap" process="true" / Map filePath="appobjects\TestOne\AddCasesFrom.rftxmap" process="false" / /Maps 对于资源文件内属性的更新，我们采用以下这些类来实现，如图 8 所示。 Properties 类是对一个资源文件的抽象，我们看到资源文件的所有属性值对都存储在属性 Properties 内。PropertyFiles 类则是对项目中用到的所有的资源文件的抽象，它包含多个 Properties 类的实例存储在哈希表内。和处理静态 TestObjectMap 一样，我们也用 XML 文件来说明哪一个资源文件需要更新，getParamXML() 方法正是用来生成该文件。 对于数据库的链接和更新我们采用两个类来实现，PropertyFile 类用来连接数据库并将资源文件中的信息更新到数据库中。Patterns 类则用来更新静态 TestObjectMap 中的多语言相关属性，如图 9 所示。 入口程序用来解析命令行参数执行相应的操作，程序的主要参数有：-gtmxml 生成 TestObjectMap 更新说明文件；-gpfxml 生成资源文件更新说明文件；-utmdb 更新数据库中静态 TestObjectMap 的信息；-upfdb 更新数据库中资源文件的信息；-ltm 生成新的静态 TestObjectMap 文件；-lpf 生成新的资源文件。 用户可以根据不同的任务来选择适当的命令行参数来运行程序，例如，当修改静态 TestObjectMap 后，调用 -gtmxml 参数生成 TestObjectMap 更新说明文件，然后调用 utmdb 参数更新数据库中信息。当用户需要测试另外一种语言时，首先调用 -gtmxml 参数生成 TestObjectMap 更新说明文件，然后调用 -ltm 参数生成新的静态 TestObjectMap 文件并将其拷贝到 RFT 的相关 TestObjectMap 路径内，之后就可以启动 RFT 进行测试了。资源文件的使用和其类似。 该方法本身还是基于静态获取多语言 UI 对象来进行识别和测试，因此在用例执行时效率高，速度快，因为基于数据库管理多语言属性的 TestObjectMap 和资源文件，因此改善了单纯使用静态获取方法的可维护性差的缺点，便于管理，更新和升级，适用于更新换代频繁，对象多而复杂的多语言 UI 测试项目。当然该方法在起始阶段需要一定的开发工作完成数据库建表，开发相应的存储过程，及 Java 代码来实现多语言属性信息的更新和下载，相对于原始的静态识别方法增加了一定的实现复杂度。 本文详细介绍了 RFT 中静态获取方法和动态获取方法在多语言 UI 测试中的实现方式，并比较了他们的优缺点，静态获取方法实现简单，运行快捷，但管理多语言 TestObjectMap 容易产生混乱；动态获取方法实现稍复杂，运行速度稍慢，但维护多语言资源文件相对简单。针对静态获取方法管理多语言 TestObjectMap 的不足，我们给出一种基于数据库管理 TestObjectMap 和资源文件的静态获取多语言 UI 的测试方法，改善了原始静态获取方法的可维护性差的缺点，当然该方法需要前期做好数据库相关的开发，也给自动化测试的开发人员提出了更高的要求。其实，每 种方法都有其各自的优势，和适用场景，也可以将他们结合起来一起灵活应用，以更好的适应随需而变的测试需求。 