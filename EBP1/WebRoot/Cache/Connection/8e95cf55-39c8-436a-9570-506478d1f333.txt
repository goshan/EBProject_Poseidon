ch
[TS]2012.10 C++标准大会视角
 2012.10 C++标准大会视角 大部分人可能不知道，在10月15号到19号的在波特兰举行的C++标准大会之前，我已经从C++之父Bjarne Stroustrup那里得到这个会议的权威消息。我们本来准备在那个星期天晚上喝一杯来庆祝C++的生日，不巧的是我们有人不能按时到达。我们确实在第二天晚上一起喝了一杯，但是是因为其他的原因，这个原因也将在最近公布出来。 为这个C++迟来的生日高兴！不管你信不信，C++已经到了第27个技术年头了，这个取决于你如何计算它的生日。如果从出版在1985年10月14号的Stroustrup的第一本C++的书算起，C++已经27岁了。 当然C++从开始有想法到酝酿可能经过了一个更长的时间。从我个人和Bjarne在波兰的交谈，以及Stroutrup的程序员之书：C++原理和实践，第22章来看，C++早在1978年就从模拟语言67和经典C语言中开始起步。我强烈推荐大家都读读这本书，因为它的教育价值，在德克萨斯州A&amp;M这本书作为许多大学新生的必修课程。我个人在征得Bjarne的同意后也将其用在我的进阶C++课程中。 上周在美丽而原始的俄勒冈州波特兰举行的C++标准大会，其实并不是第一个举行的关于C++11的大会，我们二月份在科纳也举行过一次，但这个确实是第一次开始认真准备C++17的工作。然而，C++17可能不是下一个要发布的C++标准。 我知道我曾经在以前的博客上说过在2017年之前不会有新的标准问世，但现在计划再次改变了。现在我们有意推出中间标准C++14，它用来改进C++11中的不足，这是个bug修复版本。 在科纳的会议上许多概念上的提案在会后至少有了不同程度的具体实施方案。比较有趣的是我们现在创建了许多不同的研究小组，他们关注于这个巨大的长期演进的提案。这个小组的工作除了处理那些阻扰小特性进行下去的大特性，并且还集中相关专家们去发布那些经过工作小组选择的特性。在这次会议上，我们成立了六个官方研究小组，其中有些小组在2011年5月份举行的特别并行高级峰会上就已经成立了（这个峰会我也有参加，但由于太忙了就没有写了。事实上，在上一篇博客发布之后，中间有太多的会议和事情导致我没有办法持续的更新博客，比如在罗马举行的OpenMP大会，在慕尼黑C++高级开发人员会议上的谈话，然后是现在的2012年的C++会议（也就是以前的BoostCon）, 在写这篇博客之前我才刚在这个礼拜写完OpenMP大会。自从被任命为OpenMP的CEO之后，我都没来得及写以上的会议，我以后会尽力做的更好些）。事实上，在这次特别峰会上，我展示了一些相当令人信服的证据来说明为什么事务型内存需要考虑标准化（但首先是技术规范），之后就被提名为第五个研究小组：事务型内存的主席。正如中国的一句谚语，我们生活在一个有趣的年代，承担着更多的荣誉和责任。这里列出了一些除初始并发性研究小组之外的研究小组。 1. 小组1： 并发性和平行性研究小组 2. 小组2： 模块研究小组 3. 小组3： 文件系统研究小组 4. 小组4： 网络研究小组 5. 小组5： 事务型内存 6. 小组6： 数字 在这次会议中，研究小组可能会增加到11个。其他被提议的研究小组包括Range, Reflection, Concept等。与之对比的是，C++11仅有一个研究小组：并发性研究小组，所有的研究都围绕着原子，内存模型，支持基本的线程，以及异步模式，包的管理及其他。 这么多的研究小组意味着潜在的冲突，因为他们都是做提交标准这个特定工作的，这将可能会引起交通阻塞。了解这个背景后，Bjarne认为对C++17来说，我们现有的资源只能做一个大特性，2个中等特性，以及12个小特性。现在还不清楚这个大特性会是什么。模块？模式？高级并行C++？事物内存？你希望C++17的大特性是什么呢？ 在程序上，我们为布里斯托尔会议准备了大约100个问题，其中40个问题已经处理完了。一些有趣的变化如下： 1. 在下次会议中规定只有整型数值0才会被看做是空指针常量。如果继续保持它在C++03中的定义，即任何类型的0值都可以看做是空指针常量，那在模板中的值依赖型常量有时候会被看做空指针常量，有时候则不会。这个问题在C++11一般常量表达式里已经指出来了。 2. 用const修饰的变量如果没有被显示指定为外部链接，则它就是内部链接。顺便提及，核心小组也澄清说，常量volatile变量不是一个POD类型，所以现在来说，只有非volatile 常量变量会被隐式赋予内部链接。 在图书馆中，有许多论文都描述了对常量表达式的支持，如复数，chrono, 容器和utilities,其中部分论文经过讨论后被加入为C++14的一部分，其中有一个我参与的论文是关于完全支持现在的非标准化的数字浮点类型的提议，其中一个研究小组（第6小组：数值研究小组）评估后给予非常积极的支持，另外一个我提交的论文是关于事务型内存的，我将会花一定的篇幅来描述。 从进化的角度，我们增加了一些小问题名单，以期给程序员的生活少些烦恼，更加简单。如果我知道你在C++中遇到了什么困扰，我可以写邮件给这个问题名单的持有人，芬兰代表团的团长Ville Voutilainen。这些有可能成为C++14的东西尤其受到进化小组的关注，特别是那些小的特性或者能够被修复的烦恼问题。他们能够处理大量的由C++11早期使用和实现过程中引发的问题，这也恰恰是因为那些大特性自有我上面提到的研究小组来处理。 起始于一些小的提案，有个提案已经被接受了：普通函数的返回值推导类似于lambdas的返回值推导，即只要有一个单独的可执行返回语句，那么这个返回类型也就清楚了。经过仔细考虑后，我们还批准了一项用来解决Lambda正确性和可用性方面问题的提议。Lambda另外一个令人惊讶之处在于启用了隐式常量捕获，这是它在异步中的安全使用所必需的。这意味着和普通函数相比，你必须慎重的使用volatile来修饰它，通常这也是人们奇怪的做法。基于异步的安全考虑，它一般不会被很好的接受进而被拒绝。 Kim Barrett在2012年这次的C++会议（以前叫BoostCon）中向我汇报了关于动态内存分配中对非对齐类型的问题的一场讨论。他们一致认为这个问题需要解决，但是解决方案尚有争议。其中一种认为可以为new增加重载，但是在处理偏移的问题上尚未统一。 我们已经讨论了Lambda的多态性。C++11中Lambda的单一性是因为Lambda参数总是需要一个类型占位符，而多态型Lambda并不需要如此，并且可能可以在编译器中以匿名模板类/结构体的形式而实现。多态性将使得Lambda更为灵活，这个在其他语言中已经被证明是很有用的，它其实是本地函数的另外一个名字。但还有两个问题需要处理。我们是否喜欢通用Lambda？我们知道怎样避免语法分析中可能的问题吗？许多人已经在书中或其他语言中用到了这个Lambda。 Jarko Jarvi已经做了分析并且感觉没有问题。两大主流方案是: [](I,j) j i [](auto I, auto j){return j I;} //你也可以推导其中的一个 第一个方案是使用完全最小表述方法，它规定auto必须强制加上。另外一种没有这个以auto作为占位符流行的语法，而是在[]和()之间加上 class T 。有些也支持忽略返回语句。另外也有支持点对点转换的，但是这种设计还没有为核心语言准备好。 C++11的Lambda还有其他的问题。比如它可以被值，引用所捕获，但是不支持移动捕获，这导致我们不能使用Lambda的字符流和unique_ptr。当然也有一些补救方法，如和常引用类型参数绑定在一起。我们有对移动和Lambda的惯用风格，他们还没有很好的融合在一起，我们一致认为这是个需要处理的问题。 N3401讨论了移动构造函数抑制问题，我们希望得到一个一致的移动构造函数的抑制，也就是对隐式和显示的默认移动构造函数一视同仁。Howard Hinnant研究的更多，他阐述了如果初始化做的好，那隐式生成的移动构造函数根本不应该被抑制。 Voutilainen细致的分析了以上提到的的选择，总结为如下4种： 1. Status quo, 隐式：抑制，显示：删除 2. Core 1402，隐式：抑制，显示：OK 3. Merrll，隐式：抑制，显示：抑制 4. Hinnant,隐式：OK，显示：OK（基本通过) 我们基本上都希望对隐式和显示的默认移动构造函数一视同仁，但是现在还不支持，所以最后选择了最后一种提议。 我们几乎发现了一种安全的分隔数字的解决方案。通用的_之所以有问题，是因为它和用户自定义的十六进制字面后缀相冲突了。一个自然而然的保留下划线的提议是为十六进制增加一个可选择的位置，比如Oxdead_beef aa.但在全体讨论中，Chandler Carruth认为这会导致和Objective C的不兼容。虽然我们没有和Objective C建立特定的链接，但是有大量用户将C++和Objective C的代码混合在一起使用，我们不好破坏这种组合。我们必须重新规划这个问题。最后，如果这个问题变得像看起来的那样太棘手，或许我们不会花费如此大量的精力来解决这个问题。 事实上我这里提到的问题仅仅是冰山一角。我只是尽力去描述这些我感兴趣的问题，其中有些我将作为即将来临的11月9-10号杜塞尔多夫C++用户组会议的主题。 我今年将在德国有多次旅行，期待能看到很多C++的新老朋友。但在那之前，我将在11月6号CASCON 2012会议上发表另一个主题：今天的语言怎么了? 在那之后，我作为OpenMP的CEO会在12年的超级计算机大会上上发表一系列其他的主题：关于下一代OpenMP 4.0的精彩的版本。 转移下话题，我将在接下来花一些时间来说说事务型内存研究组的工作和未来C++标准的最新时间表。 我所在的研究组叫事务型内存（SG5），SG5每两周举行一个电话会议，在上周举行了一次C++标准面对面会议。小组成员们带来了基于已经研究了四年的C++ 事务型内存草案V1.1版本的两种类型的事务提案，这个提案包括两种类型的事务： 1. 隔离的事务，它是通过某些种安全注释的方式从非事务型的代码以及其他事务中隔离出来的。 2. 普通事务，它允许和其他费事务型的代码进行交流，但事务之间是相互隔离的。 这两种类型的事务，以取名为例，它们的名字已经被接受了，并且看起来很清楚合理。我们进一步的展示了不同的技术来支持各种级别的安全注释，从完全静态的编译时检查到不同级别的动态检查，从而来减轻程序员的负担。 我们小组的目的就是将这个完整描述的草案提交为Brisol 2013大会的一个技术规范, 我甚至听说有些人建议将这个提交为标准，如果小组觉得这个草案足够简单的话。 现在你们中有些人可能会想这是否为时过早，我则要说硬件已经好了，如intel发布了Haswell, IBM有BG/Q，以及之前Sun的Rock。软件事务型内存的支持已经有相当长一段时间了，如intel的STM支持1.0 版草案，以及最近的GCC C++ 4.7几乎完全支持1.1版草案了。 如果你仍然以为这个提之过早，听我说，汉斯的发现之一就是，在泛型编程中锁是不切实际的，因为在实例化之前，锁的顺序是不可见的。在C++11中对锁（和原子）的介绍，已经成为一个不可避免的难题。事务型内存是解决这个问题的一种方法，它同样也能帮助在不规则数据结构和只读结构中的细粒度锁。 现有的原子和锁任意组合引发的实际问题，乐观的猜测可以通过类似于事务性内存的技术来完美解决。如果你认为这可能没有充分的使用经验，我们将在五月份的提案中展示，从我们长期研究的研究生索引应用程序的数据来看，整体的编程工作有14%的效率提升，事务型内存也表现很好。 最后，如果你仍然担心事务型内存是否够快？有很多不同的软件事务型内存系统，性能特征也不一样，所以可能总有一种可以满足你的要求。特别的，在最近对Quake游戏的10万玩家同时在线的UT 性能研究中，玩家的要求是所有行动的原子性和一致性，我们发现即使在纯粹的STM系统中，对4-8个进程仍然有33%的性能提升。 事务型内存正以许多不同的形式到来（硬件，软件，混合系统，锁），许多其他语言已经支持了事务型内存，对C++来说这仍然是一个合适的地方，是时候准备一个拿的出手的提案了。 在标准大会中几乎有太多的报告，任何提议，如果没有花费很多的时间和精力，然后以一个合理的博客形式被接受，那都将是不完整的。那天的全体会议中，所有的主席和子研究小组的主席的汇报花了五个半小时，这还是在没有争议的情况下。我无法想象如果有争论的话，大会将会超时多长时间。 我想说，会有很多新的提案加入到将来的C++中，我（和许多其他博客的作者）会尽量保持更新和联系在一起，我希望你能从中更接近C++。 对于未来，杰出的小组领导人Herb Sutter提出了一个这样的时间表，假设了0.1和0.2的C++标准会议点。他确定了C++14和C++17，同时还有文件系统研究组 （SG3）技术规范的发布时间。其他研究组也在考虑发布技术规范。我们事务型内存研究组（SG5）正在准备一个技术规范，将会在2015-2017年间某个时间发布。网络研究组（SG4）则打算每年发布一个技术规范，最开始的是URL规范。 2012.2：C++14新工作项目提议；文件系统研究组（SG3）新工作项目提议 2013.1：C++14委员会草案；文件系统研究组（SG3）初步的技术规范草案 2013.2：C++14国际标准草案；文件系统研究组（SG3）票选技术规范草案。 2014.1：C++14最终版国际标准草案 2014.2：C++17委员会草案1 2015.1：C++17委员会草案1/2 2015.2：C++17委员会草案2 2016.1 2016.2：C++17国际标准草案 2017.1：C++17最终版国际标准草案 当然以上只是个暂行的时间表，在实际运行中很可能会变化。 好吧，这是一个很长的帖子，这是由于我个人的原因，我因为领导了这么多不同的研究小组而导致长时间没有更新。 实际上有更多的消息我可以写，我将来会尽量写短一点的博客，更新更频繁点。但是，我们的确生活在一个有趣的时代。 